/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: wallmasterr (https://sketchfab.com/wallmasterr)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/tenhun-falling-spaceman-fanart-9fd80b6a259f41fd99e6f56eee686dc5
Title: Tenhun Falling spaceman (FanArt)
*/

import React, { useEffect, useMemo, useRef } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { KTX2Loader } from "three/examples/jsm/loaders/KTX2Loader.js";
import { closeOverlayLoader } from "../loader";
import { withBase } from "../utils/paths";
import { easing } from "maath";

const MODEL_URLS = {
  high: withBase("models/astronaut/tenhun_falling_spaceman_fanart_lod0.glb"),
  medium: withBase("models/astronaut/tenhun_falling_spaceman_fanart_lod1.glb"),
  low: withBase("models/astronaut/tenhun_falling_spaceman_fanart_lod2.glb"),
};

const disposeMaterial = (material) => {
  if (!material) return;
  Object.values(material).forEach((value) => {
    if (value && value.isTexture) {
      value.dispose();
    }
  });
  if (material.dispose) {
    material.dispose();
  }
};

const damp = (current, target, lambda, delta) =>
  current + (target - current) * (1 - Math.exp(-lambda * delta));

export function Astronaut({ quality = "high", active = true, ...props }) {
  const group = useRef();
  const baseRotation = useRef([6, -0.6, 0]);
  const currentY = useRef(5);
  const targetY = useRef(-1);
  const { gl } = useThree();

  const modelUrl = MODEL_URLS[quality] || MODEL_URLS.high;
  const ktx2Loader = useMemo(() => {
    const loader = new KTX2Loader();
    loader.setTranscoderPath(withBase("basis/"));
    loader.detectSupport(gl);
    return loader;
  }, [gl]);

  const { scene, animations } = useGLTF(modelUrl, false, true, (loader) => {
    loader.setKTX2Loader(ktx2Loader);
  });
  const { actions } = useAnimations(animations, group);
  useEffect(() => {
    if (animations.length > 0) {
      actions[animations[0].name]?.play();
    }
  }, [actions, animations]);
  useEffect(() => {
    closeOverlayLoader();
  }, []);
  useEffect(() => {
    currentY.current = 5;
  }, [modelUrl]);
  useEffect(() => {
    return () => {
      scene.traverse((child) => {
        if (!child.isMesh) return;
        if (child.geometry) {
          child.geometry.dispose();
        }
        const material = child.material;
        if (Array.isArray(material)) {
          material.forEach(disposeMaterial);
        } else {
          disposeMaterial(material);
        }
      });
      useGLTF.clear(modelUrl);
      ktx2Loader.dispose();
    };
  }, [ktx2Loader, modelUrl, scene]);

  useFrame((state, delta) => {
    if (!active) return;
    if (!group.current) return;
    currentY.current = damp(currentY.current, targetY.current, 4, delta);
    group.current.position.y = currentY.current;

    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
    const x = clamp(state.mouse.x, -0.5, 0.5);
    const y = clamp(state.mouse.y, -0.4, 0.4);
    const targetRotation = [
      baseRotation.current[0] + -y * 0.25,
      baseRotation.current[1] + x * 0.45,
      baseRotation.current[2],
    ];
    easing.dampE(group.current.rotation, targetRotation, 0.35, delta);
  });
  return (
    <group
      ref={group}
      {...props}
      dispose={null}
      rotation={baseRotation.current}
      scale={props.scale || 1.6}
      position={props.position || [1.5, -7, 1]}
    >
      <primitive object={scene} />
    </group>
  );
}
